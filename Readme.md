[设计模式学习路线 (yuque.com)](https://bcdh.yuque.com/staff-wpxfif/resource/gemmvk)

## 学习顺序

根据使用频率、难易度、面试考察率等综合排序，仅供参考，并不绝对！

优先：

1. 单例模式
2. ~~工厂模式~~
3. 迭代器模式
4. ~~策略模式~~
5. 建造者模式
6. 模板方法模式
7. 代理模式
8. 责任链模式
9. ~~抽象工厂模式~~
10. 适配器模式
11. ~~观察者模式~~
12. 外观模式

一般：

1桥接模式
2组合模式
3装饰器模式
4状态模式
5访问者模式
6中介者模式
7命令模式
8备忘录模式

低优先：

1原型模式
2享元模式
3解释器模式

## 设计模式六大原则

**1、开闭原则（Open Close Principle）**

开闭原则的意思是：**对扩展开放，对修改关闭**
。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP
是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

**3、依赖倒转原则（Dependence Inversion Principle）**

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

**4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

**5、迪米特法则，又称最少知道原则（Demeter Principle）**

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

**6、合成复用原则（Composite Reuse Principle）**

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

## 单例模式

## 工厂模式

**定义**：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**作用**：主要解决接口选择的问题。通过传入参数的不同返回不同的实例

**使用场景：**

1. 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
2. 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。
3. 设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类共同实现一个接口。

**工厂模式包含以下几个核心角色：**

- 抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。
- 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。
- 抽象工厂（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。
- 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。

**实现**：

![image-20231024155539139](https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231024155539139.png)

1. 首先了解一下我们的需求：要创建三个几何图形，因为都是几何，所有我们先创建一个接口`Shape`
   （抽象产品），再建三个几何类实现接口`Shape`（具体产品）
2. 然后我们再建一个`ShapeFactory`（抽象工厂），在这里根据用户传入的type，进行判断需要创建哪个几何类
3. 在测试类创建（具体工厂），并创建不同的（具体产品），调用方法测试

**TIPS：**

简单工厂模式

该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象

![image-20231024162640426](https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231024162640426.png)

- 优点：将对象的创建交给专门的工厂类负责，实现了对象的创建和对象的使用分离。

- 缺点：工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，比如有人是绿皮肤，上面的工厂类显然满足不了，需要增加一个
  if 判断分支才能支持。而且当产品类型较多时，简单工厂的 if 判断将会非常多，不容易维护。

工厂方法模式

工厂方法模式将生成具体产品的任务分发给具体的产品工厂，也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。

![image-20231024162705992](https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231024162705992.png)

- 优点：遵循了开闭原则，扩展性极强。比如现在要增加一个绿皮肤的人类，我们只需要增加一个创建绿皮肤人类的工厂，这个工厂继承自抽象工厂即可，不需要改变原有代码，可维护性高。

- 缺点：增加了类的数量，当有成千上万个类型的产品时，就需要有成千上万个工厂类来生产这些产品。

抽象工厂模式

上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品**Phone**（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？

最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是PC。但同时也就意味着我们要完全复制和修改Phone生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。

抽象工厂模式通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。

![image-20231024162749829](https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231024162749829.png)

- 优点：增加固定类型产品的不同具体工厂比较方便。例如现在女娲要创造一个绿皮肤的人，只需要再创建一个绿皮肤人的工厂继承抽象工厂就可以了。

- 缺点：类图优点复杂，可读性没有工厂方法模式那么好。

**总结：**

简单工厂：通过一个公共**工厂直接**创建具体类

工厂方法：通过**具体工厂实现抽象工厂**创建具体类

抽象工厂：通过具体工厂实现公共工厂创建**不同**具体类

**典型示例：**

- java.util.Calendar, ResourceBundle and NumberFormat getInstance() 使用了工厂方法模式；
- valueOf() 在包装类中，如Boolean, Integer 也使用了工厂方法模式；
- collection的迭代器也有用到

## 策略模式

**定义**：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。

**作用**：在有多种算法相似的情况下，解决使用 if...else 所带来的复杂和难以维护的问题。/**解决继承不能实现的横向代码复用，有时候组合优于继承
**

**使用场景：**

1. 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
2. 一个系统需要动态地在几种算法中选择一种。
3. 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。

**策略模式包含以下几个核心角色：**

- 环境（Context）：维护一个对策略对象的引用，负责将客户端请求委派给具体的策略对象执行。环境类可以通过依赖注入、简单工厂等方式来获取具体策略对象。
- 抽象策略（Abstract Strategy）：定义了策略对象的公共接口或抽象类，规定了具体策略类必须实现的方法。
- 具体策略（Concrete Strategy）：实现了抽象策略定义的接口或抽象类，包含了具体的算法实现。

**实现**：

![image-20231023153847429](https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231023153847429.png)

1. 首先是先要有一个接口`Strategy`，这个类有一个方法`doOperation`
2. 这个`doOperation`方法有不同的类重写了，如`OperationAdd`、`OperationMultiply`等
3. 现在有个环境`Context`要定义这个接口，注意此环境代码

```java
public class Context {
   private final Strategy strategy;
 
   public Context(Strategy strategy){
      this.strategy = strategy;
   }
 
   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);
   }
}
```

4. 在Demo里面实现这个接口，new的时候就直接传入具体类/对应的重写方法

```java
      Context context = new Context(new OperationAdd());
      System.out.println("10 + 5 = " + context.executeStrategy(10, 5));
 
      context = new Context(new OperationSubtract());
      System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
```

**典型示例**

在JDK中最经典的使用策略模式的例子就是`Collections.sort(List<T> list, Comparator<? super T> c)`
方法，这个方法接受一个比较器`Compartor`参数，客户端在运行时可以传入一个比较器的实现，`sort()`方法中根据不同实现，按照不同的方式进行排序。

## 观察者模式

**定义**：当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。

**作用**：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

**使用场景：**

- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
- 一个对象必须通知其他对象，而并不知道这些对象是谁。
- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

**观察者模式包含以下几个核心角色：**

- 主题（Subject）：也称为被观察者或可观察者，它是具有状态的对象，并维护着一个观察者列表。主题提供了添加、删除和通知观察者的方法。
- 观察者（Observer）：观察者是接收主题通知的对象。观察者需要实现一个更新方法，当收到主题的通知时，调用该方法进行更新操作。
- 具体主题（Concrete Subject）：具体主题是主题的具体实现类。它维护着观察者列表，并在状态发生改变时通知观察者。
- 具体观察者（Concrete Observer）：具体观察者是观察者的具体实现类。它实现了更新方法，定义了在收到主题通知时需要执行的具体操作。

**实现**：【倒推】

![image-20231023164154002](https://cdn.jsdelivr.net/gh/kixuan/PicGo/images/image-20231023164154002.png)

1. 首先要有被观察者`Subject`类，这个类有观察者`observers`，和对应的add和remove方法；还有改变状态方法`setState`
   ，这个方法里面除了改变state还要有一个通知`observers`让他们`update`的方法
2. 对应的观察者`observers`类就应该有①被观察者`Subject`类，②`update`方法
3. 在demo里面，我们首先创建三个`observers`，然后调用`Subject`的`setState`方法，查看`observers`类`update`得怎么样

**典型示例**【待try】

Spring Event（Application Event）其实就是一个观察者设计模式，一个 Bean 处理完成任务后希望通知其它 Bean 或者说一个 Bean
想观察监听另一个Bean 的行为。
